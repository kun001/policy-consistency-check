## 数据存储方案

### 1. 设计目标与范围

- 支撑上传文档从原始文件到入库向量的整条流水线，保证可追溯、可重试、可扩展。
- 统一管理 collection、文档、分块、关键元信息及向量化结果，确保跨系统数据一致。
- 兼容本地磁盘 + SQLite 的 MVP 方案，并为后续迁移到云存储、云数据库留出空间。

### 2. 存储目录规范

根路径建议配置为 `storage/`（可通过环境变量覆盖），目录结构如下：

```
storage/
├── collections.json           # （可选）collection 元数据缓存
├── docs/
│   ├── <collection_id>/
│   │   ├── <doc_id>/
│   │   │   ├── raw/           # 原始上传文件，保留原始文件名
│   │   │   ├── parsed/        # 解析后的纯文本、结构化数据
│   │   │   │   ├── content.txt
│   │   │   │   ├── toc.json
│   │   │   │   ├── segments.json
│   │   │   │   └── keywords.json
│   │   │   ├── logs/          # 处理日志、错误信息
│   │   │   │   └── pipeline.log
│   │   │   └── assets/        # 其他派生文件，如图片、表格、PDF 预览等
│   │   └── index.json         # （可选）collection 内文档清单缓存
└── tmp/                       # 任务运行时的临时文件，处理完成后清理
```

- 所有文档相关的目录均按照 `collection_id/doc_id` 分组，方便权限控制和归档。
- `doc_id` 使用数据库主键或 UUID，和数据库记录保持一致。
- 上传原始文件应保留原始文件名，存放在 `raw/` 下；其余派生文件以规范化命名（`content.txt`、`toc.json` 等）。
- 临时处理文件统一放在 `storage/tmp/`，任务结束后清理，避免占用空间。

### 3. 数据库 Schema 设计（SQLite / Postgres 通用）

以下字段类型以 SQLite 为例，可根据目标数据库进行细化（如使用 `UUID`、`JSONB`）。所有表默认包含 `created_at`、`updated_at`（`DATETIME`，默认当前时间）。

#### 3.1 collections

| 字段        | 类型       | 说明                                          |
| ----------- | ---------- | --------------------------------------------- |
| id          | TEXT (PK)  | collection 唯一标识，可使用 UUID              |
| name        | TEXT       | 对外显示名称                                  |
| description | TEXT       | 描述信息                                      |
| provider    | TEXT       | 知识库后端类型（如 `weaviate`、`milvus`） |
| config      | TEXT(JSON) | 具体的连接/模型配置，如向量维度、类名等       |
| is_active   | INTEGER    | 是否启用（1/0）                               |

#### 3.2 documents

| 字段            | 类型       | 说明                                                           |
| --------------- | ---------- | -------------------------------------------------------------- |
| id              | TEXT (PK)  | 文档唯一标识，生成的 `doc_id`                                |
| collection_id   | TEXT (FK)  | 关联 `collections.id`                                        |
| source_filename | TEXT       | 用户上传时的文件名                                             |
| storage_path    | TEXT       | 存储相对路径，如 `docs/<collection>/<doc>/raw/<file>`        |
| original_mime   | TEXT       | MIME 类型或扩展名                                              |
| status          | TEXT       | 当前状态：`uploaded`/`processing`/`succeeded`/`failed` |
| page_count      | INTEGER    | 页数（如有）                                                   |
| word_count      | INTEGER    | 字数（如有）                                                   |
| summary         | TEXT       | 摘要（来自解析）                                               |
| keywords        | TEXT(JSON) | 顶层关键字列表                                                 |
| parsing_payload | TEXT(JSON) | 解析任务的返回内容（如任务 ID、原始结果 URL）                  |
| last_error      | TEXT       | 最近一次失败原因                                               |
| version         | INTEGER    | 文档版本号，缺省为 1                                           |

索引建议：`CREATE INDEX idx_documents_collection ON documents(collection_id);`

#### 3.3 document_versions（可选）

在需要保留历史版本时使用，字段与 `documents` 基本相同，额外包含 `document_id`（原始文档 ID）和 `is_current` 标记。

#### 3.4 chunks

| 字段             | 类型       | 说明                                                    |
| ---------------- | ---------- | ------------------------------------------------------- |
| id               | TEXT (PK)  | chunk 唯一标识                                          |
| doc_id           | TEXT (FK)  | 关联 `documents.id`                                   |
| collection_id    | TEXT (FK)  | 冗余字段，便于跨表查询                                  |
| chunk_index      | INTEGER    | 在文档中的顺序，从 0 开始                               |
| title            | TEXT       | 该分块对应的章节/标题                                   |
| section_path     | TEXT       | 章节层级路径，如 `["第一章","第一节"]`（JSON 字符串） |
| content          | TEXT       | 分块正文                                                |
| token_count      | INTEGER    | 分块 token 数                                           |
| metadata         | TEXT(JSON) | 其他元信息（页码、作者、标签等）                        |
| weaviate_id      | TEXT       | 对应向量库中的对象 ID                                   |
| embedding_status | TEXT       | 向量化状态：`pending`/`embedded`/`failed`         |
| last_error       | TEXT       | 向量化失败信息                                          |

索引建议：

- `CREATE INDEX idx_chunks_doc ON chunks(doc_id);`
- `CREATE INDEX idx_chunks_weaviate ON chunks(weaviate_id);`

#### 3.5 keywords（可选）

当需要更细的标签管理时使用。

| 字段   | 类型                        | 说明                           |
| ------ | --------------------------- | ------------------------------ |
| id     | INTEGER (PK, AUTOINCREMENT) |                                |
| doc_id | TEXT (FK)                   | 文档 ID                        |
| term   | TEXT                        | 关键词                         |
| weight | REAL                        | 权重或得分                     |
| source | TEXT                        | 来源（`auto`/`manual` 等） |

#### 3.6 process_logs（可选）

便于追踪流水线执行情况。

| 字段    | 类型                        | 说明                                                             |
| ------- | --------------------------- | ---------------------------------------------------------------- |
| id      | INTEGER (PK, AUTOINCREMENT) |                                                                  |
| doc_id  | TEXT (FK)                   | 文档 ID                                                          |
| stage   | TEXT                        | 流程阶段：`upload`/`parse`/`chunk`/`embed`/`import` 等 |
| status  | TEXT                        | 阶段状态：`started`/`succeeded`/`failed`                   |
| message | TEXT                        | 日志详情或错误堆栈                                               |
| extra   | TEXT(JSON)                  | 额外上下文（耗时、调用参数等）                                   |

### 4. 元数据与向量库协同

- 写入 Weaviate 时，需在对象 `metadata` 中携带 `collection_id`、`doc_id`、`chunk_id`、`chunk_index` 等字段，保证可追溯。
- 数据库中的 `weaviate_id` 与 Weaviate `uuid` 对应，删除或重建向量时以此为依据。
- 若使用 Weaviate 的自定义 class，可将 `collection_id` 映射为 class 名称或 class 的一个字段；`config` 字段用于保存 class/tenant 相关配置。
- 可在 `chunks` 表中缓存 embedding 向量（如 `BLOB` 或 `TEXT`），用于快速比对或重新导入；若仅依赖外部向量库，可省略。

### 5. 数据生命周期与运维

1. **上传**：生成 `doc_id`，写入 `documents` 状态 `uploaded`，保存原文件到 `storage/docs/<collection>/<doc>/raw/`。
2. **解析**：生成结构化文件放入 `parsed/`，更新 `documents` 的 `summary`、`keywords` 等字段。若失败，记录 `last_error` 并保持 `processing` 状态，等待人工或自动重试。
3. **分块**：将 `segments.json` 中的内容写入 `chunks` 表，并存储 chunk 层级信息；此阶段可将中间数据保存在 `parsed/`。
4. **向量化**：对每个 chunk 调用 embedding 接口，更新 `chunks.embedding_status`，并在成功后调用 Weaviate 批量写入；失败时记录日志以便重试。
5. **完成**：所有 chunk 成功写入 Weaviate 后，将 `documents.status` 更新为 `succeeded`，记录完成时间。
6. **重试/回滚**：利用 `process_logs` 和 `last_error` 进行针对性重试；如需回滚，可删除 `chunks` 和 Weaviate 对象，同时清理磁盘缓存。
7. **删除**：删除 collection 或文档时，先软删数据库记录，再触发后台任务清理 Weaviate 对象及 `storage/docs/<collection>/<doc>` 目录。

### 6. 扩展与迁移建议

- **数据库扩展**：当并发增大时，可迁移到 Postgres/MySQL，并将 `TEXT(JSON)` 字段替换为 `JSONB`/`JSON`，加上更细的索引与分表策略。
- **对象存储**：将 `storage/` 替换为云存储（OSS/S3），目录结构保持一致，通过配置项获取基地址。
- **多租户支持**：在 `collections` 和 `documents` 中加入 `tenant_id` 字段，实现不同租户的数据隔离。
- **审计与权限**：必要时新增 `document_access` 表记录用户与文档的授权关系；对 `process_logs` 开启审计级别的保留策略。
